name: deploy-to-kind

on:
  push:
    branches:
      - "**"
    paths:
      - 'Dockerfile'
      - 'apps/**'
      - 'k8s/**'
  pull_request:
    branches:
      - "**"
    paths:
      - 'Dockerfile'
      - 'apps/**'
      - 'k8s/**'
  workflow_dispatch:

jobs:
  build:
    name: Build and push image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image: ${{ steps.set-image.outputs.image }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image (latest + sha)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/arculus-devops-challenge:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/arculus-devops-challenge:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Export image name
        id: set-image
        run: |
          IMAGE="ghcr.io/${{ github.repository_owner }}/arculus-devops-challenge:${{ github.sha }}"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
  deploy:
    name: Deploy to kind cluster
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout (repo files for k8s)
        uses: actions/checkout@v4

      - name: Set up kind cluster
        uses: helm/kind-action@v1.10.0
        with:
          cluster_name: deploy-kind

      - name: Install kubectl (linux/amd64)
        run: |
          set -euo pipefail
          KUBECTL_VERSION="v1.27.0"
          OS="linux"
          ARCH="amd64"
          URL="https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/${OS}/${ARCH}/kubectl"
          echo "Downloading kubectl from ${URL}"
          curl -fsSL -o kubectl "${URL}"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/kubectl
          kubectl version --client
      - name: Verify kind cluster
        run: |
          kubectl cluster-info
          kubectl get nodes
      - name: Deploy namespace and DB
        run: |
          set -euo pipefail
          kubectl apply --validate=false -f k8s/namespace.yaml
          kubectl apply --validate=false -f k8s/secret-db.yaml
          kubectl apply --validate=false -f k8s/postgres-deployment.yaml
          kubectl apply --validate=false -f k8s/postgres-service.yaml
          echo "Waiting for Postgres to be ready..."
          kubectl rollout status deploy/postgres -n orders --timeout=180s || {
            echo "Postgres rollout did not complete in time. Pods in orders namespace:"
            kubectl get pods -n orders || true
            kubectl describe deploy/postgres -n orders || true
          }
      - name: Deploy orders app (deployment, service, ingress)
        run: |
          set -euo pipefail
          kubectl apply --validate=false -f k8s/app-deployment.yaml
          kubectl apply --validate=false -f k8s/app-service.yaml
          kubectl apply --validate=false -f k8s/ingress.yaml
          echo "Waiting for orders-app to be ready (non-fatal timeout)..."
          kubectl rollout status deploy/orders-app -n orders --timeout=180s || {
            echo "orders-app rollout did not complete in time. Pods in orders namespace:"
            kubectl get pods -n orders || true
            kubectl describe deploy/orders-app -n orders || true
            POD=$(kubectl get pods -n orders -l app=orders-app -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
            if [ -n "$POD" ]; then
              echo "Logs from pod $POD:"
              kubectl logs "$POD" -n orders || true
            else
              echo "No orders-app pod found."
            fi
          }
      - name: Smoke test /health via ClusterIP
        run: |
          set -euo pipefail
          # Robust health check: simple busybox pod, no -i/--tty, retry loop
          kubectl run curl -n orders --image=busybox:1.36 --restart=Never -- \
            sh -c 'for i in $(seq 1 30); do echo "Attempt $i: GET /health"; wget -qO- http://orders:8000/health && exit 0; sleep 2; done; echo "Health check failed"; exit 1'
          kubectl delete pod curl -n orders --ignore-not-found=true
      
      - name: Collect cluster logs
        if: always()
        run: |
          set -euo pipefail
          mkdir -p artifacts
          kubectl get pods -A -o wide > artifacts/pods.txt
          kubectl get svc -A > artifacts/services.txt
          kubectl describe deploy -n orders > artifacts/orders-deploy.txt || true
          kubectl logs -n orders -l app=orders-app > artifacts/orders-app-logs.txt || true
          kubectl logs -n orders -l app=postgres > artifacts/postgres-logs.txt || true

      - name: Upload cluster logs artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-to-kind-logs
          path: artifacts
          retention-days: 7