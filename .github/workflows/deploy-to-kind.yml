name: deploy-to-kind

on:
  push:
    branches: [ "main", "part3-deploy-to-kind" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build:
    name: Build and push image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image: ${{ steps.set-image.outputs.image }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Build and push image
        id: build-image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/arculus-devops-challenge:${{ github.sha }}

      - name: Export image name
        id: set-image
        run: |
          IMAGE="ghcr.io/${{ github.repository_owner }}/arculus-devops-challenge:${{ github.sha }}"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy to cluster (Terraform)
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      NAMESPACE: orders

    steps:
      - name: Checkout (repo files for terraform / k8s)
        uses: actions/checkout@v4

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.14.4

      - name: Install kubectl (linux/amd64)
        run: |
          set -euo pipefail
          KUBECTL_VERSION="v1.27.0"
          OS="linux"
          ARCH="amd64"
          URL="https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/${OS}/${ARCH}/kubectl"
          echo "Downloading kubectl from ${URL}"
          curl -fsSL -o kubectl "${URL}"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/kubectl
          kubectl version --client --short

      - name: Restore kubeconfig from secret
        run: |
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 --decode > "${{ github.workspace }}/kubeconfig"
          chmod 600 "${{ github.workspace }}/kubeconfig"
          echo "KUBECONFIG=${{ github.workspace }}/kubeconfig" >> $GITHUB_ENV
        shell: bash

      - name: Verify cluster access
        run: |
          if [ -z "${KUBECONFIG:-}" ]; then
            echo "KUBECONFIG not set. Exiting."
            exit 1
          fi
          kubectl version --short
          kubectl cluster-info
        env:
          KUBECONFIG: ${{ env.KUBECONFIG }}

      - name: Create TLS secret (self-signed) if missing
        run: |
          # create a self-signed cert if orders-tls does not exist
          if ! kubectl get secret orders-tls -n ${NAMESPACE} >/dev/null 2>&1; then
            echo "Generating self-signed cert for orders.local"
            openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
              -subj "/CN=orders.local/O=orders" \
              -keyout key.pem -out cert.pem
            kubectl create secret tls orders-tls -n ${NAMESPACE} --cert=cert.pem --key=key.pem --dry-run=client -o yaml | kubectl apply -f -
            rm -f cert.pem key.pem
            echo "Created orders-tls in namespace ${NAMESPACE}"
          else
            echo "orders-tls already exists"
          fi
        shell: bash
        env:
          KUBECONFIG: ${{ env.KUBECONFIG }}

      - name: Create DB secret from GitHub Secrets (safe, no plaintext in repo)
        run: |
          # ensure required repo secrets exist (DB_NAME, DB_USER, DB_PASSWORD)
          if [ -z "${{ secrets.DB_NAME }}${{ secrets.DB_USER }}${{ secrets.DB_PASSWORD }}" ]; then
            echo "One or more DB secrets (DB_NAME, DB_USER, DB_PASSWORD) are missing. Exiting."
            exit 1
          fi
          kubectl create secret generic orders-db-credentials -n ${NAMESPACE} \
            --from-literal=POSTGRES_DB="${{ secrets.DB_NAME }}" \
            --from-literal=POSTGRES_USER="${{ secrets.DB_USER }}" \
            --from-literal=POSTGRES_PASSWORD="${{ secrets.DB_PASSWORD }}" \
            --from-literal=DATABASE_URL="postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@postgres.${NAMESPACE}.svc.cluster.local:5432/${{ secrets.DB_NAME }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "Applied orders-db-credentials secret in ${NAMESPACE}"
        shell: bash
        env:
          KUBECONFIG: ${{ env.KUBECONFIG }}

      - name: Terraform init
        working-directory: ./terraform
        run: terraform init

      - name: Terraform apply
        working-directory: ./terraform
        env:
          KUBECONFIG: ${{ env.KUBECONFIG }}
        run: |
          terraform apply -auto-approve -var="image_tag=${{ needs.build.outputs.image }}" -var="namespace=${NAMESPACE}"